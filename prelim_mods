#### -------------------------------------------------------------------------------- ####
#### Preliminary Bayesian multi-species models
#### -------------------------------------------------------------------------------- ####

# Created by Andrew, worked through by Andrew/Austin

library(R2jags)
library(dclone)      # built-in functionality for parallel MCMC with jags via jags.parfit()


#setwd("~/Dropbox/____Projects____/BBS_Project") # Andrew
#setwd("C:/Users/Tingley Lab_2/Dropbox/BBS_Project") #Tingley lab computer
setwd("./BBS_Data")

## Load and organize data
load("passeriformes_dataset.Rdata")
birds <- passeriformes[,c(1:3,10,11,18,26,327,331,339:345)] # simplify dataset

## Remove birds with less than 100 lag observations and less than 20 different sites
birds <- birds[which(birds$English_Common_Name != "Abert's Towhee"),]
birds <- birds[which(birds$English_Common_Name != "American Dipper"),]
birds <- birds[which(birds$English_Common_Name != "American Pipit"),]
birds <- birds[which(birds$English_Common_Name != "American Tree Sparrow"),]
birds <- birds[which(birds$English_Common_Name != "Bay-breasted Warbler"),]
birds <- birds[which(birds$English_Common_Name != "Bell's Sparrow"),]
birds <- birds[which(birds$English_Common_Name != "Black-capped Vireo"),]
birds <- birds[which(birds$English_Common_Name != "Black-crested Titmouse"),]
birds <- birds[which(birds$English_Common_Name != "Blackpoll Warbler"),]
birds <- birds[which(birds$English_Common_Name != "Boat-tailed Grackle"),]
birds <- birds[which(birds$English_Common_Name != "Bohemian Waxwing"),]
birds <- birds[which(birds$English_Common_Name != "Boreal Chickadee"),]
birds <- birds[which(birds$English_Common_Name != "Cape May Warbler"),]
birds <- birds[which(birds$English_Common_Name != "Cerulean Warbler"),]
birds <- birds[which(birds$English_Common_Name != "Chestnut-collared Longspur"),]
birds <- birds[which(birds$English_Common_Name != "Common Redpoll"),]
birds <- birds[which(birds$English_Common_Name != "Connecticut Warbler"),]
birds <- birds[which(birds$English_Common_Name != "Golden-crowned Sparrow"),]
birds <- birds[which(birds$English_Common_Name != "Gray-cheeked Thrush"),]
birds <- birds[which(birds$English_Common_Name != "Juniper Titmouse"),]
birds <- birds[which(birds$English_Common_Name != "Lawerence's Warbler"),]
birds <- birds[which(birds$English_Common_Name != "Le Conte's Thrasher"),]
birds <- birds[which(birds$English_Common_Name != "Lucy's Warbler"),]
birds <- birds[which(birds$English_Common_Name != "McCown's Longspur"),]
birds <- birds[which(birds$English_Common_Name != "Nelson's Sparrow"),]
birds <- birds[which(birds$English_Common_Name != "Northwestern Crow"),]
birds <- birds[which(birds$English_Common_Name != "Palm Warbler"),]
birds <- birds[which(birds$English_Common_Name != "Pine Grosbeak"),]
birds <- birds[which(birds$English_Common_Name != "Rusty Blackbird"),]
birds <- birds[which(birds$English_Common_Name != "Sprague's Pipit"),]
birds <- birds[which(birds$English_Common_Name != "Swainson's Warbler"),]

## Refactor birds
birds$aou <- factor(birds$aou)

## Scale raw temperature and precipitation values
birds$breeding_avg_high_year_1_scaled <- (birds$breeding_avg_high_year_1 - mean(birds$breeding_avg_high_year_1))/sd(birds$breeding_avg_high_year_1)
birds$breeding_avg_precip_year_1_scaled <- (birds$breeding_avg_precip_year_1 - mean(birds$breeding_avg_precip_year_1))/sd(birds$breeding_avg_precip_year_1)

####--------------------------------------- High Temp Model ------------------------------------- ####

hightemp.function <- function(){
  
  ## Prior distributions on parameters
  b.0 ~ dnorm(0,0.001)
  b.relative_niche_high ~ dnorm(0,0.001)       # Is the site in the warm part of the thermal niche?
  b.year1 ~ dnorm(0,0.001)                        # What was the temperature of that year?
  b.relative_year1 ~ dnorm(0,0.001)               # Was this site particularly warm relative to the mean of this site?
  
  b.niche_year1 ~ dnorm(0,0.001)                # Interaction between actual temperature and thermal niche
  b.niche_relative_year1 ~ dnorm(0,0.001)         # Interaction between relative temperature and thermal niche
  
  tau ~ dgamma(0.001,0.001)
  
  tau.species ~ dgamma(0.001, 0.001)  # could change to simag~unif()
  sigma.species <- 1/sqrt(tau.species)
  
  ## Process model
  for(i in 1:n.obs){
    mu[i] <- b.0 + b.relative_niche_high*relative_niche_high[i] +                     # effect of relative niche temp
      b.year1*year1[i] +                                                       # effect of year 1 temp
      b.relative_year1*relative_year1[i] +                                     # effect of relative year 1 temp
      b.niche_year1*relative_niche_high[i]*year1[i] +                        # effect of niche and year 1 temp interaction
      b.niche_relative_year1*relative_niche_high[i]*relative_year1[i] +     # effect of nich and relative year 1 temp interaction
      b.species[species[i]]                                                    # random intercept
    
    y[i] ~ dlnorm(mu[i], tau)                                                               # log normal response
  }
  
  ## Random intercept for each species 
  for(j in 1:n.species){
    b.species[j] ~ dnorm(0, tau.species)
  }
}


## Set data for the model
jags.list.hightemp <- list(n.obs=nrow(birds), 
                           n.species=length(unique(birds$aou)),
                           relative_niche_high = birds$breeding_mean_high_zscore,
                           year1 = birds$breeding_avg_high_year_1_scaled,
                           relative_year1 = birds$breeding_avg_high_year_1_zscore,
                           species = birds$aou,
                           y = birds$r_star)


params.save <- c("b.0", "b.year1", "b.relative_niche_high", " b.relative_year1", "b.niche_year1", "b.niche_relative_year1",  "sigma.species")

ptm <- proc.time()



cl <- makePSOCKcluster(3)   # Make your socket cluster and name it 'cl'.  nc is the number of cores you want your cluster to have--generally the number of chains you want to run.
tmp <- clusterEvalQ(cl, library(dclone))  # Check that `dclone` is loaded on each of cl's workers. dclone includes JAGS functionality
parLoadModule(cl, "glm")  # load the JAGS module 'glm' on each worker
parListModules(cl)  # make sure previous line worked.
## Run the model here:
hightemp.mod <- jags.parfit(cl=cl, data=jags.list.hightemp, 
                            params=params.save, model=hightemp.function, 
                            n.chains=3, n.adapt=1000, n.update=5000, thin=10, n.iter=20000)
stopCluster(cl)    # close out the cluster.
proc.time() - ptm

save(hightemp.mod, file = "hightemp_mod.Rdata")



####--------------------------------------- Precipitation Model ------------------------------------- ####

precip.function <- function(){
  
  ## Prior distributions on parameters
  b.0 ~ dnorm(0,0.001)
  b.relative_niche_precip ~ dnorm(0,0.001)        # Is the site in the warm part of the thermal niche?
  b.year1 ~ dnorm(0,0.001)                        # What was the temperature of that year?
  b.relative_year1 ~ dnorm(0,0.001)               # Was this site particularly warm relative to the mean of this site?
  
  b.niche_year1 ~ dnorm(0,0.001)                  # Interaction between actual temperature and thermal niche
  b.niche_relative_year1 ~ dnorm(0,0.001)         # Interaction between relative temperature and thermal niche
  
  tau ~ dgamma(0.001,0.001)
  
  tau.species ~ dgamma(0.001, 0.001)  # could change to simag~unif()
  sigma.species <- 1/sqrt(tau.species)
  
  ## Process model
  for(i in 1:n.obs){
    mu[i] <- b.0 + b.relative_niche_precip*relative_niche_precip[i] +                       # effect of relative niche precip
      b.year1*year1[i] +                                                       # effect of year 1 precip
      b.relative_year1*relative_year1[i] +                                     # effect of relative year 1 precip
      b.niche_year1*relative_niche_precip[i]*year1[i] +                        # effect of niche and year 1 precip interaction
      b.niche_relative_year1*relative_niche_precip[i]*relative_year1[i] +      # effect of nich and relative year 1 precip interaction
      b.species[species[i]]                                                    # random intercept
    
    y[i] ~ dlnorm(mu[i], tau)                                                               # log normal response
  }
  
  ## Random intercept for each species 
  for(j in 1:n.species){
    b.species[j] ~ dnorm(0, tau.species)
  }
}


## Set data for the model
jags.list.precip <- list(n.obs=nrow(birds), 
                         n.species=length(unique(birds$aou)),
                         relative_niche_precip = birds$breeding_mean_precip_zscore,
                         year1 = birds$breeding_avg_precip_year_1_scaled,
                         relative_year1 = birds$breeding_avg_precip_year_1_zscore,
                         species = birds$aou,
                         y = birds$r_star)


params.save <- c("b.0", "b.year1", "b.relative_niche_precip", " b.relative_year1", "b.niche_year1", "b.niche_relative_year1",  "sigma.species")


ptm <- proc.time()
cl <- makePSOCKcluster(3)   # Make your socket cluster and name it 'cl'.  nc is the number of cores you want your cluster to have--generally the number of chains you want to run.
tmp <- clusterEvalQ(cl, library(dclone))  # Check that `dclone` is loaded on each of cl's workers. dclone includes JAGS functionality
parLoadModule(cl, "glm")  # load the JAGS module 'glm' on each worker
parListModules(cl)  # make sure previous line worked.
## Run the model here:
precip.mod <- jags.parfit(cl=cl, data=jags.list.precip, 
                          params=params.save, model=precip.function, 
                          n.chains=3, n.adapt=1000, n.update=5000, thin=10, n.iter=20000)


stopCluster(cl)    # close out the cluster.
proc.time() - ptm

save(precip.mod, file = "precip_mod.Rdata")


